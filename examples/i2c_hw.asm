
.equ test = 3

#include "m328Pdef.inc"

.equ freq = 16000000 ; Hz
.equ target_freq = 100000 ; Hz

.equ cycles_per_us = freq / 1000000 ; 1 us = 10^-6 s

.equ delay_in_cycles = (freq / target_freq)/2

#define ERROR_LED 7
#define SUCCESS_LED 6
#define TRIGGER_PIN 0
#define DISPLAY_RESET_PIN 4

#define SUCCESS_LED_ON  sbi PORTD, SUCCESS_LED
#define SUCCESS_LED_OFF cbi PORTD, SUCCESS_LED

#define ERROR_LED_ON  sbi PORTD, ERROR_LED
#define ERROR_LED_OFF cbi PORTD, ERROR_LED

#define DISPLAY_I2C_ADDR %01111000
#define DISPLAY_WIDTH_IN_PIXEL 128
#define DISPLAY_HEIGHT_IN_PIXEL 64

#define GLYPH_WIDTH_IN_BITS 8 
#define GLYPH_HEIGHT_IN_BITS 8

.equ GLYPH_WIDTH_IN_BYTES = GLYPH_WIDTH_IN_BITS/8
.equ BYTES_PER_GLYPH = (GLYPH_WIDTH_IN_BITS*GLYPH_HEIGHT_IN_BITS)/8

#define BYTES_PER_ROW DISPLAY_WIDTH_IN_PIXEL/8

.equ FRAMEBUFFER_SIZE = (DISPLAY_WIDTH_IN_PIXEL*DISPLAY_HEIGHT_IN_PIXEL)/8
; .equ FRAMEBUFFER_SIZE = 768
; SSD1306 request types

.equ REQ_SINGLE_COMMAND = 0x80
.equ REQ_COMMAND_STREAM = 0x00
.equ REQ_SINGLE_DATA = 0xc0
.equ REQ_DATA_STREAM = 0x40

; Display commands

#define CMD_DISPLAY_ON 0
#define CMD_ROW_ADDRESSING_MODE 1

jmp init  ; RESET
jmp onirq ; INT0 - ext IRQ 0
jmp onirq ; INT1 - ext IRQ 1
jmp onirq ; PCINT0 - pin change IRQ 
jmp onirq ; PCINT1 - pin change IRQ
jmp onirq ; PCINT2 - pin change IRQ
jmp onirq ; WDT - watchdog IRQ
jmp onirq ; TIMER2_COMPA - timer/counter 2 compare match A
jmp onirq ; TIMER2_COMPB - timer/counter 2 compare match B
jmp onirq ; TIMER2_OVF - timer/counter 2 overflow
jmp onirq ; TIMER1_CAPT - timer/counter 1 capture event
jmp onirq ; TIMER1_COMPA 
jmp onirq ; TIMER1_COMPB
jmp onirq ; TIMER1_OVF
jmp onirq ; TIMER0_COMPA
jmp onirq ; TIMER0_COMPB
jmp onirq ; TIMER0_OVF
jmp onirq ; STC - serial transfer complete (SPI)
jmp onirq ; USUART Rx complete
jmp onirq ; USUART Data register empty
jmp onirq ; USUART Tx complete
jmp onirq ; ADC conversion complete
jmp onirq ; EEPROM ready
jmp onirq ; Analog comparator
jmp onirq ; 2-wire interface I2C
jmp onirq ; Store program memory ready

; ========================
; HW init
; ========================
init:
; clear status register
          cli
	eor r1,r1
	out 0x3f,r1
; initialize stack pointer
	ldi r28,0xff
	ldi r29,0x08
	out 0x3e,r29	; SPH = 0x08
	out 0x3d,r28	; SPL = 0xff
; call main program
again:
	rcall main
	rcall wait_for_button  
          rjmp again
onirq:
	jmp 0x00
; ==========================
; main program starts here
; ==========================
main:
          rcall reset
          
          rcall wait_for_button  
          
	ldi r16, CMD_ROW_ADDRESSING_MODE
	rcall send_command
          brcs error	

	ldi r16, CMD_DISPLAY_ON
	rcall send_command
          brcs error	

	rcall clear_framebuffer

; INPUT: r16 - character to write
; INPUT: r17 - row (X)
; INPUT: r18 - column (Y)
	ldi r16,0
	ldi r17,0
	ldi r18,0
	rcall write_char

	ldi r16,0
	ldi r17,1
	ldi r18,1
	rcall write_char

	rcall send_framebuffer
	brcs error

          SUCCESS_LED_ON
          ret
.error        
	ERROR_LED_ON

          rcall wait_for_button  	
	rjmp main
; ====
; reset bus
; =====
reset:
;	cbi DDRD,DISPLAY_RESET_PIN ; set to input
;          sbi PORTD,DISPLAY_RESET_PIN ; Enable pull-up resistor
	sbi DDRD,DISPLAY_RESET_PIN ; set to output

	sbi DDRD,ERROR_LED ; set to output
	sbi DDRD,SUCCESS_LED ; set to output
	cbi DDRB,TRIGGER_PIN ; set to input
;          setup TWI rate 
          lds r16,TWSR
          andi r16,%11111100
          sts TWSR,r16 ; prescaler bits = 00 => factor 1x
          ldi r16,72
          sts TWBR,r16 ; factor
          ERROR_LED_OFF
          SUCCESS_LED_OFF
	rjmp reset_display

; ======
; Reset display
; ======
reset_display:
	cbi PORTD, DISPLAY_RESET_PIN
	ldi r18,255
	rcall usleep  	
	sbi PORTD, DISPLAY_RESET_PIN
	ret
	
; ======
; wait for button press 
; ======
wait_for_button:
          ldi r18,255
          call usleep
.wait_released
          sbic PINB , TRIGGER_PIN
          rjmp wait_released
.wait_pressed
          sbis PINB , TRIGGER_PIN
          rjmp wait_pressed
          ldi r18,255
          call usleep
          ret

; ====
; send command.
; INPUT: r16 - command table entry index 
; SCRATCHED: r2,r16,r19:r18,r20,r31:r30
; ====

send_command:
          lsl r16 ; *4 => size of command table entries
          lsl r16
          ldi r31 , HIGH(commands)
          ldi r30 , LOW(commands)
	eor r2,r2
          add r30,r16
          adc r31,r2
          lpm r16,Z+ ; cmd address low
          lpm r17,Z+ ; cmd address hi
          lpm r28,Z+ ; LOW(number of bytes in cmd )
          lpm r29,Z+ ; HIGH(number of bytes in cmd )
          movw Z,r17:r16 ; Z = r17:r16
          call send_bytes
          ret
          
; ====== send bytes
; Assumption: CLK HI , DATA HI when method is entered
; INPUT: r31:r30 (Z register) start address of bytes to transmit
; INPUT: r29:r28 - number of bytes to transmit
; SCRATCHED: r16,r20,r31:r30
; RETURN: Carry clear => transmission successful , Carry set => Transmission failed
; ======
send_bytes:
; send START
          rcall send_start
	brcs send_failed
.data_loop
          lpm r16,Z+
          rcall send_byte
          brcs send_failed             
          sbiw r29:r28,1
          brne data_loop          
; transmission successful
	rcall send_stop       	
          clc
          ret
.send_failed
          rcall send_stop
	sec
	ret

; =====
; send stop
; SCRATCHED: r16,r0,r1,r17,r27:r26
; =============

send_stop:
	ldi r16, (1<<TWINT)|(1<<TWEN)| (1<<TWSTO) 
	sts TWCR, r16
          ldi r18,5
          call usleep
	ret

; ===================
;  Send Start command and slave address 
; SCRATCHED: r16
; ====================

send_start:
; send START
          ldi r16, (1<<TWINT)|(1<<TWSTA)|(1<<TWEN) 
          sts TWCR, r16
; wait for START transmitted
.wait_start
          lds r16,TWCR
          sbrs r16,TWINT 
          rjmp wait_start

; check for transmission error
          lds r16,TWSR
          andi r16, 0xF8 
	cpi r16, 0x08 ; 0x08 = status code: START transmitted 
	brne send_failed
; transmit address (first byte)
          ldi r16,DISPLAY_I2C_ADDR
          sts TWDR, r16 
          ldi r16, (1<<TWINT) | (1<<TWEN) 
          sts TWCR, r16
; wait for address transmission
.wait_adr
	lds r16,TWCR
	sbrs r16,TWINT 
	rjmp wait_adr
; check status
	lds r16,TWSR
	andi r16, 0xF8 
	cpi r16, 0x18 ; 0x18 = status code: Adress transmitted,ACK received
	brne send_failed
          clc
	ret
.send_failed
	sec
	ret

; =========
; send a single byte
; INPUT: r16 - byte to send
; SCRATCHED: r16
; RETURN: Carry set = transmission error, carry clear = transmission ok
; =========
send_byte:
	sts TWDR, r16 
	ldi r16, (1<<TWINT) | (1<<TWEN) 
	sts TWCR, r16                    
.wait_data
	lds r16,TWCR 
	sbrs r16,TWINT 
	rjmp wait_data
; check transmission
	lds r16,TWSR
	andi r16, 0xF8 
	cpi r16, 0x28 ; 0x28 = status code: data transmitted,ACK received 
	brne send_failed
          clc
	ret
.send_failed
          sec
	ret


; ====== send full framebuffer
; Assumption: CLK HI , DATA HI when method is entered
; INPUT: r31:r30 (Z register) start address of bytes to transmit
; INPUT: r29:r28 - number of bytes to transmit
; SCRATCHED: r16,r20,r31:r30
; RETURN: Carry clear => transmission successful , Carry set => Transmission failed
; ======
send_framebuffer:
	rcall send_start
          brcs error
	ldi r16,REQ_DATA_STREAM
	rcall send_byte
	brcs error
           ldi r31, HIGH(framebuffer) ;Z
           ldi r30, LOW(framebuffer)
           ldi r29, HIGH(FRAMEBUFFER_SIZE)
           ldi r28, LOW(FRAMEBUFFER_SIZE)
.loop	
	ld r16,Z+
           rcall send_byte
	brcs error
	sbiw r29:r28,1
	brne loop
	rcall send_stop
	clc
	ret
.error
	rcall send_stop
	sec
	ret

; ========
; write one ASCII glyph into the framebuffer
; INPUT: r16 - character to write
; INPUT: r17 - row (X)
; INPUT: r18 - column (Y)
; SCRATCHED: r16
; =======
write_char:
; map ASCII code to glyph  
	ldi r31,HIGH(charset_mapping)
	ldi r30,LOW(charset_mapping)
	add r30,r16
	ldi r16,0
          adc  r31,r16
	lpm r0 , Z ; fetch glyph offset into charset ROM
	ldi r16, BYTES_PER_GLYPH ; 8x8 pixel per glyph
	mul r16,r0	 ; r1:r0 now hold offset of glyph in flash memory
; add start address of charset ROM 
	ldi r31,HIGH(charset)
	ldi r30,LOW(charset)
	add r30,r0
	adc r31,r1
; Z now holds start of glyph in font ROM
	ldi r16, GLYPH_WIDTH_IN_BYTES
	mul r17,r16 ;  X * GLYPH_WIDTH_IN_BYTES => r1:r0
	movw r3:r2,r1:r0 ; backup result
          ldi r16,BYTES_PER_ROW
	mul r18,r16 ; Y * BYTES_PER_ROW => r1:r0
	add r0,r2
	adc r1,r3
; r1:r0 now hold offset into framebuffer
	ldi r29,HIGH(framebuffer)	
	ldi r28,LOW(framebuffer)
	add r28,r0
	adc r29,r1
; r29:r28 holds pointer into framebuffer where to write glyph data
	ldi r16 , GLYPH_HEIGHT_IN_BITS ; write 8 bytes (TODO: Hard-coded glyph heigh)
.row_loop
	lpm r18,Z+
	st r29:r28,r18
	adiw r29:r28,BYTES_PER_ROW
	dec r16
	brne row_loop
	ret
	
; ======
; clears the screen buffer
; SCRATCHED: r16, r29:r28, r31:r30
; ======

clear_framebuffer:
           ldi r16,0x00
           ldi r31, HIGH(framebuffer) ; Z
           ldi r30, LOW(framebuffer) ; Z
           ldi r29, HIGH(FRAMEBUFFER_SIZE)
           ldi r28, LOW(FRAMEBUFFER_SIZE)
.clr_loop  
           st Z+, r16
           sbiw r29:r28,1
           brne clr_loop
           ret

; =========
; sleep for up to 255 micro seconds
;
; >>>> Must NEVER be called with a value less than 2 us (infinite loop) <<<<

; IN: r18 = number of microseconds to sleep
; SCRATCHED: r0,r1,r17,r27:r26
;
; Total execution time: 
; +1 cycles for caller having to load the R18 register with time to wait
; +4 cycles for CALL invoking this method
; +5 cycles for calculating cycle count
; +4 cycles for RET 
; =========
usleep:
          ldi r17 , cycles_per_us ; 1 cycle
          mul r18 , r17 ; 1 cycle , result is in r1:r0     
          movw r27:r26 , r1:r0 ; 1 cycle
          sbiw r27:r26,14  ; 2 cycles , adjust for cycles spent invoking this method + preparation  
.loop     sbiw r27:r26,4 ; 2 cycles , subtract 4 cycles per loop iteration      
	brpl loop ; 2 cycles, 1 cycle if branch not taken
	ret ; 4 cycles

commands: .dw cmd1,2
          .dw cmd2,3
cmd1:     .db REQ_SINGLE_COMMAND,0xaf ; switch display on
cmd2:     .db REQ_COMMAND_STREAM,0x20, %00 ; set horizontal addressing mode

charset:
    .db 0x3c,0x66,0x6e,0x6e,0x60,0x62,0x3c,0x00 ; '@'
    .db 0x18,0x3c,0x66,0x7e,0x66,0x66,0x66,0x00 ; 'a'
    .db 0x7c,0x66,0x66,0x7c,0x66,0x66,0x7c,0x00 ; 'b'
    .db 0x3c,0x66,0x60,0x60,0x60,0x66,0x3c,0x00 ; 'c'
    .db 0x78,0x6c,0x66,0x66,0x66,0x6c,0x78,0x00 ; 'd'
    .db 0x7e,0x60,0x60,0x78,0x60,0x60,0x7e,0x00 ; 'e'
    .db 0x7e,0x60,0x60,0x78,0x60,0x60,0x60,0x00 ; 'f'
    .db 0x3c,0x66,0x60,0x6e,0x66,0x66,0x3c,0x00 ; 'g'
    .db 0x66,0x66,0x66,0x7e,0x66,0x66,0x66,0x00 ; 'h'
    .db 0x3c,0x18,0x18,0x18,0x18,0x18,0x3c,0x00 ; 'i'
    .db 0x1e,0x0c,0x0c,0x0c,0x0c,0x6c,0x38,0x00 ; 'j'
    .db 0x66,0x6c,0x78,0x70,0x78,0x6c,0x66,0x00 ; 'k'
    .db 0x60,0x60,0x60,0x60,0x60,0x60,0x7e,0x00 ; 'l'
    .db 0x63,0x77,0x7f,0x6b,0x63,0x63,0x63,0x00 ; 'm'
    .db 0x66,0x76,0x7e,0x7e,0x6e,0x66,0x66,0x00 ; 'n'
    .db 0x3c,0x66,0x66,0x66,0x66,0x66,0x3c,0x00 ; 'o'
    .db 0x7c,0x66,0x66,0x7c,0x60,0x60,0x60,0x00 ; 'p'
    .db 0x3c,0x66,0x66,0x66,0x66,0x3c,0x0e,0x00 ; 'q'
    .db 0x7c,0x66,0x66,0x7c,0x78,0x6c,0x66,0x00 ; 'r'
    .db 0x3c,0x66,0x60,0x3c,0x06,0x66,0x3c,0x00 ; 's'
    .db 0x7e,0x18,0x18,0x18,0x18,0x18,0x18,0x00 ; 't'
    .db 0x66,0x66,0x66,0x66,0x66,0x66,0x3c,0x00 ; 'u'
    .db 0x66,0x66,0x66,0x66,0x66,0x3c,0x18,0x00 ; 'v'
    .db 0x63,0x63,0x63,0x6b,0x7f,0x77,0x63,0x00 ; 'w'
    .db 0x66,0x66,0x3c,0x18,0x3c,0x66,0x66,0x00 ; 'x'
    .db 0x66,0x66,0x66,0x3c,0x18,0x18,0x18,0x00 ; 'y'
    .db 0x7e,0x06,0x0c,0x18,0x30,0x60,0x7e,0x00 ; 'z'
    .db 0x3c,0x30,0x30,0x30,0x30,0x30,0x3c,0x00 ; '['
    .db 0x3c,0x0c,0x0c,0x0c,0x0c,0x0c,0x3c,0x00 ; ']'
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; ' '
    .db 0x18,0x18,0x18,0x18,0x00,0x00,0x18,0x00 ; '!'
    .db 0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00 ; '"'
    .db 0x66,0x66,0xff,0x66,0xff,0x66,0x66,0x00 ; '#'
    .db 0x18,0x3e,0x60,0x3c,0x06,0x7c,0x18,0x00 ; '$'
    .db 0x62,0x66,0x0c,0x18,0x30,0x66,0x46,0x00 ; '%'
    .db 0x3c,0x66,0x3c,0x38,0x67,0x66,0x3f,0x00 ; '&'
    .db 0x06,0x0c,0x18,0x00,0x00,0x00,0x00,0x00 ; '''
    .db 0x0c,0x18,0x30,0x30,0x30,0x18,0x0c,0x00 ; '('
    .db 0x30,0x18,0x0c,0x0c,0x0c,0x18,0x30,0x00 ; ')'
    .db 0x00,0x66,0x3c,0xff,0x3c,0x66,0x00,0x00 ; '*'
    .db 0x00,0x18,0x18,0x7e,0x18,0x18,0x00,0x00 ; '+'
    .db 0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30 ; ','
    .db 0x00,0x00,0x00,0x7e,0x00,0x00,0x00,0x00 ; '-'
    .db 0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00 ; '.'
    .db 0x00,0x03,0x06,0x0c,0x18,0x30,0x60,0x00 ; '/'
    .db 0x3c,0x66,0x6e,0x76,0x66,0x66,0x3c,0x00 ; '0'
    .db 0x18,0x18,0x38,0x18,0x18,0x18,0x7e,0x00 ; '1'
    .db 0x3c,0x66,0x06,0x0c,0x30,0x60,0x7e,0x00 ; '2'
    .db 0x3c,0x66,0x06,0x1c,0x06,0x66,0x3c,0x00 ; '3'
    .db 0x06,0x0e,0x1e,0x66,0x7f,0x06,0x06,0x00 ; '4'
    .db 0x7e,0x60,0x7c,0x06,0x06,0x66,0x3c,0x00 ; '5'
    .db 0x3c,0x66,0x60,0x7c,0x66,0x66,0x3c,0x00 ; '6'
    .db 0x7e,0x66,0x0c,0x18,0x18,0x18,0x18,0x00 ; '7'
    .db 0x3c,0x66,0x66,0x3c,0x66,0x66,0x3c,0x00 ; '8'
    .db 0x3c,0x66,0x66,0x3e,0x06,0x66,0x3c,0x00 ; '9'
    .db 0x00,0x00,0x18,0x00,0x00,0x18,0x00,0x00 ; ':'
    .db 0x00,0x00,0x18,0x00,0x00,0x18,0x18,0x30 ; ';'
    .db 0x0e,0x18,0x30,0x60,0x30,0x18,0x0e,0x00 ; '<'
    .db 0x00,0x00,0x7e,0x00,0x7e,0x00,0x00,0x00 ; '='
    .db 0x70,0x18,0x0c,0x06,0x0c,0x18,0x70,0x00 ; '>'
    .db 0x3c,0x66,0x06,0x0c,0x18,0x00,0x18,0x00 ; '?' 
charset_mapping:
    .db 0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27
    .db 0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f
    .db 0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37
    .db 0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f
    .db 0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x5b,0x00,0x5d,0x00,0x00
    .db 0x00,0x61,0x62,0x63,0x64,0x65,0x66,0x67
    .db 0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f
    .db 0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77
    .db 0x78,0x79,0x7a,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    .db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00

.dseg 
     .byte 0x100 ; TODO: hack to skip register file
framebuffer:
    .byte 1024